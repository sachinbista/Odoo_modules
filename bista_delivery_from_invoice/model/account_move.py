from odoo import models, fields, api, _


class AccountMove(models.Model):
    _inherit = "account.move"

    @api.depends('picking_ids')
    def _compute_picking_ids(self):
        for order in self:
            order.delivery_count = len(order.picking_ids)

    delivery_count = fields.Integer(string='Delivery Orders', compute='_compute_picking_ids')
    picking_ids = fields.One2many('stock.picking', 'move_id', string='Transfers')
    procurement_group_id = fields.Many2one('procurement.group', 'Procurement Group', copy=False)

    def action_view_delivery(self):
        # picking_ids = self.env['stock.picking'].search([('move_id','=',self.id)])
        return self._get_action_view_picking(self.picking_ids)

    def _get_action_view_picking(self, pickings):
        '''
        This function returns an action that display existing delivery orders
        of given sales order ids. It can either be a in a list or in a form
        view, if there is only one delivery order to show.
        '''
        action = self.env["ir.actions.actions"]._for_xml_id("stock.action_picking_tree_all")

        if len(pickings) > 1:
            action['domain'] = [('id', 'in', pickings.ids)]
        elif pickings:
            form_view = [(self.env.ref('stock.view_picking_form').id, 'form')]
            if 'views' in action:
                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
            else:
                action['views'] = form_view
            action['res_id'] = pickings.id
        # Prepare the context.
        picking_id = pickings.filtered(lambda l: l.picking_type_id.code == 'outgoing')
        if picking_id:
            picking_id = picking_id[0]
        else:
            picking_id = pickings[0]
        # View context from sale_renting `rental_schedule_view_form`
        cleaned_context = {k: v for k, v in self._context.items() if k != 'form_view_ref'}
        action['context'] = dict(cleaned_context, default_partner_id=self.partner_id.id, default_picking_type_id=picking_id.picking_type_id.id, default_origin=self.name, default_group_id=picking_id.group_id.id)
        return action

    def post_credit_note_return_picking(self):
        if self.company_id.is_delivery_invoice and self.move_type == 'out_refund':
            self.action_post()
            if not self.picking_ids:
                self.invoice_line_ids.with_context(return_picking=True)._action_launch_stock_rule()

    # def action_post(self):
    #     res = super().action_post()
    #     if self.company_id.is_delivery_invoice and not self.move_type == 'out_refund':
    #         picking_action = self.create_picking()
    #         if isinstance(picking_action, dict):
    #             return picking_action
    #     return res

    # def create_picking(self):
    #     self.invoice_line_ids._action_launch_stock_rule()
    #     return

    # def create_picking(self):
    #     # Skip sanity check by setting context
    #     self.env.context = dict(self.env.context, skip_sanity_check=True)
    #     self.invoice_line_ids._action_launch_stock_rule()
    #     return


class AccountMoveLine(models.Model):
    _inherit = "account.move.line"

    def _prepare_procurement_group_vals(self):
        return {
            'name': self.move_id.name or self.move_id.display_name,
            'move_type': 'direct',
            # 'sale_id': self.order_id.id,
            'partner_id': self.move_id.partner_id.id,
        }

    # def _action_launch_stock_rule(self, previous_product_uom_qty=False):
    #     """
    #     Launch procurement group run method with required/custom fields generated by a
    #     sale order line. procurement group will launch '_run_pull', '_run_buy' or '_run_manufacture'
    #     depending on the sale order line product rule.
    #     """
    #     procurements = []
    #     for line in self:
    #         line = line.with_company(line.company_id)
    #         qty = 0
    #         procurements_vals = line._prepare_procurement_group_vals()
    #         group_id = line._get_procurement_group()
    #         if not group_id:
    #             group_id = self.env['procurement.group'].create(procurements_vals)
    #             line.move_id.procurement_group_id = group_id
    #         else:
    #             updated_vals = {}
    #             if group_id.partner_id != line.move_id.partner_id:
    #                 updated_vals.update({'partner_id': line.move_id.partner_id.id})
    #             # if group_id.move_type != line.order_id.picking_policy:
    #             #     updated_vals.update({'move_type': 'direct'})
    #             if updated_vals:
    #                 group_id.write(updated_vals)
    #
    #         values = line._prepare_procurement_values(group_id=group_id)
    #         product_qty = line.quantity - qty
    #         line_uom = line.product_uom_id
    #         quant_uom = line.product_id.uom_id
    #         product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
    #         procurements.append(line._create_procurement(product_qty, procurement_uom, values))
    #     if procurements:
    #         self = self.with_context(move_id=self.move_id.id)
    #         self.env['procurement.group'].run(procurements)
    #
    #     invoice_ids = self.mapped('move_id')
    #     for invoice in invoice_ids:
    #         pickings_to_confirm = invoice.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
    #         if pickings_to_confirm:
    #             # Trigger the Scheduler for Pickings
    #             # pickings_to_confirm.action_confirm()
    #             pickings_to_confirm.button_validate()
    #     return True



    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
        """
        Launch procurement group run method with required/custom fields generated by a
        sale order line. This will skip sanity checks for stock quants and set the pickings to done.
        """
        procurements = []
        for line in self:
            line = line.with_company(line.company_id)
            qty = 0
            procurements_vals = line._prepare_procurement_group_vals()
            group_id = line._get_procurement_group()
            if not group_id:
                group_id = self.env['procurement.group'].create(procurements_vals)
                line.move_id.procurement_group_id = group_id
            else:
                updated_vals = {}
                if group_id.partner_id != line.move_id.partner_id:
                    updated_vals.update({'partner_id': line.move_id.partner_id.id})
                if updated_vals:
                    group_id.write(updated_vals)

            values = line._prepare_procurement_values(group_id=group_id)
            product_qty = line.quantity - qty
            line_uom = line.product_uom_id
            quant_uom = line.product_id.uom_id
            product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
            procurements.append(line._create_procurement(product_qty, procurement_uom, values))

        if procurements:
            if self._context.get("return_picking"):
                self = self.with_context(move_id=self.move_id.id,picking_type_id=self.company_id.return_pickng_type.id,)
            else:
                self = self.with_context(move_id=self.move_id.id,picking_type_id=self.company_id.out_picking_type.id,)
            self.env['procurement.group'].run(procurements)

        # Skip any checks related to available stock quants
        invoice_ids = self.mapped('move_id')
        for invoice in invoice_ids.filtered(lambda i: i.move_type != 'out_refund'):
            if not invoice.shopify_order_id:
                pickings_to_confirm = invoice.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
                if pickings_to_confirm:
                    for picking in pickings_to_confirm:
                        for move in picking.move_ids:
                            move.quantity = move.product_uom_qty
                        picking.with_context(skip_sanity_check=True).button_validate()
        return True

    def _prepare_procurement_values(self, group_id=False):
        values = {}
        self.ensure_one()
        # warehouse_id = self.env['stock.warehouse'].search([('company_id','=',self.move_id.company_id.id)])
        values.update({
            'group_id': group_id,
            'warehouse_id': self.company_id.warehouse_id,
            'partner_id': self.move_id.partner_id.id,
            'product_description_variants': "",
            'company_id': self.move_id.company_id,
            'sequence': self.sequence,
        })
        return values

    def _create_procurement(self, product_qty, procurement_uom, values):
        self.ensure_one()
        return self.env['procurement.group'].Procurement(
            self.product_id, product_qty, procurement_uom, self.move_id.partner_id.property_stock_customer,
            self.product_id.display_name, self.move_id.name, self.move_id.company_id, values)

    def _get_procurement_group(self):
        return self.move_id.procurement_group_id